(in-package :zf)

;; CLOS で学ぶ集合論その５（続き）

;; 順序数の説明を空集合からの冪集合の生成で説明した．すなわち，空集合を
;; =0 と表記したとき，=1 は (power-set =0)，=2 は (power-set =1)，=3 は
;; (power-set =2)，等々である．

(defvar =0 +empty+)
;=>  =0

(defvar =1 (power-set =0))
;=>  =1

(defvar =2 (power-set =1))
;=>  =2

(defvar =3 (power-set =2))
;=>  =3

;; ところが，=4 までは楽に計算できるが，=5 になるといつまでたっても答え
;; は返ってこない．ちなみに，=0 の要素数は0，=1 は1，=2 は2 ，=3 は4，
;; =4 は16 となる．一般に冪集合の要素数は元の集合の要素数を n とすると
;; 2n 個になる．すなわち =5 の要素数はいきなり 65536 個になってしまうの
;; である．

;; 今，簡単のために集合を要素とするのではなく，(powerset (set-of 0 1 2
;; 3)) のように数字を要素とする冪集合について，計算時間を調べてみると，
;; 私の持っている最高級のPC，intel core i5，2.67GHz×2，4GB，Windows7
;; で次のようになる．

;; powerset-time
;; http://livedoor.blogimg.jp/s-koide/imgs/d/c/dcdb1509.png

;; 横軸が要素数（カージナリティ），縦軸が対数目盛でms単位である．要素数
;; 11のときに，およそ13分であるが，これが要素数16になると，対数目盛を単
;; 純に外挿して，なんと２年半の計算時間になる．これには正直びっくりした．
;; なるほどいつまでたっても計算が終わらないわけだ．

;; 順序数を定義するのに，冪集合を用いるのではなく，successor を用いる方
;; 法がある．すなわち，=0 を空集合としたとき，=1 は (union-of =0
;; (set-of =0))，=2 は (union-of =1 (set-of =1))，のようにする方法だ，
;; これだと要素数は１ステップで一つしか増えない．しかも，冪集合において
;; 成立した重要な性質，低位の集合は高位の集合の部分集合でもあるし要素で
;; もあるという性質が成立している．

(setq =1 (union-of =0 (set-of =0)))
;=> {{}}
(setq =2 (union-of =1 (set-of =1)))
;=> {{},{{}}}
(setq =3 (union-of =2 (set-of =2)))
;=> {{},{{}},{{},{{}}}}
(defvar =4 (union-of =3 (set-of =3)))
;=> =4
(defvar =5 (union-of =4 (set-of =4)))
;=> =5
(defvar =6 (union-of =5 (set-of =5)))
;=> =6
(in =5 =6)
;=> T
(subset-p =5 =6)
;=> T
(in =2 =6)
;=> T
(subset-p =2 =6)
;=> T

;; というわけで，以後ここではブルバキ流に，順序数の導入をsuccessor を用
;; いて行うことにする．（まだまだ続く）

;; ここでsuccessor を次のように定義する．

(defun suc (ord)
  (union-of ord (set-of ord)))

;; これを使うと，空集合を0として，順序数は次のように定義できる．

(defparameter =0 +empty+)
;=>  =0

(defparameter =1 (suc =0))
;=>  =1

(defparameter =2 (suc =1))
;=>  =2

(defparameter =3 (suc =2))
;=>  =3

=3
;=>  {{},{{}},{{},{{}}}}

;; しかも，このsuccessor で冪集合と違って都合のいいのは，それぞれの順序
;; 数の集合としてのカージナリティが順序数と合致していることだ．

;; ??? set-elements
#|(defun card (set)
  (length (member-of set)))|#

(defun card (set)
  (length (set-elements set)))

(card =0)
;=>  0
(card =2)
;=>  2
(card =3)
;=>  3

;; だから，加減算だってまさに整数と同じように計算できる．

(eql (card =3) (+ (card =0) (card =1) (card =2)))
;=>  T

(eql (- (card =3) (card =1)) (card =2))
;=>  T

;;さて，n 番目の順序数を得るためには，suc をn 回繰り返して計算すればよ
;;い．普通なら順序数を得るための関数は次のようになるだろう．

(defmethod make-load-form ((obj set) &optional env)
  (declare (ignore env))
  `(set ',(set-elements obj)))

(defun *make-ord (n &optional (pre +empty+))
  (if (= n 0) pre
    (*make-ord (1- n) (suc pre))))

;; なぜわざわざオプショナル引数 pre を設けたかお分かりだろうか？末尾再
;; 帰にして，実質ループにするためである．

(*make-ord 3)
;=>  {{},{{}},{{},{{}}}}
(equals =3 (*make-ord 3))
;=>  T

;; 前々回に述べたように，suc を延々と無限に続けた先に，得られるものが
;; ω である．普通のシステムでは無限とか ω みたいなものは実装できない．
;; ところが我々はすでに末尾再帰を用いた継続とか，遅延（delay）を持って
;; いる．遅延についてはこのブログでは説明してこなかった．PAIP の
;; auxfns.lisp にある，あるいは私のscheme まとめに示した util.lisp にあ
;; る delay と force を見てほしい（両者同じもの）．継続を使えば，その時
;; 点での計算をあと延ばしにできるし，delay を使っても，本当に必要になっ
;; たときのみ，フォームを実行できる．PAIP に載っている delay の応用例は，
;; 無限に続く整数のシーケンスを生成するものだ．今ここでそれを紹介すると，
;; ここでの議論やコードとごっちゃになりそうなのでやめておくが，興味のあ
;; るかたはこれの280ページから282ページまでを読んでほしい．残念ながら
;; 283ページからないが，要点は十分つかめるだろう．

;; 今ここでやりたいことは， ω の概念をなんとかLisp で扱えるようにでき
;; ないか，ということなのだ．もちろん本当に無限の順序数が得られるわけが
;; ない．でもあたまの中でこれ ω ね，無限の要素を持つ無限の順序数ね，と
;; 考えるように，Lisp でも何とか扱えないかということなのだ．有理数だっ
;; て本当は無限にあるけれど，われわれはLisp の世界でそれを厳密にあつか
;; うことができる．要するに理論的に正しい枠組みを実装して，必要な場合だ
;; け必要な計算ができればよいのだ．だから，超限順序数に関する計算の枠組
;; みさえできれば，いいんじゃないの，ということなのだ．

;;これで後々にも十分かどうかは，今さだかではないが，とりあえずここでコー
;;ド化したものはこんなものだ．

(defun make-ord (cont &optional n)
  (if (equal n 0) (funcall cont)
    (if (not (null n))
        (make-ord #'(lambda () (suc (funcall cont))) (1- n))
      (make-ord #'(lambda () (suc (funcall cont)))))))

;; ここで cont は継続で，トップレベルでこれに #'(lambda () +empty+) を
;; 与える．n は求める n 番目の順序数を指定するパラメータだ．このコード
;; は n がゼロになるまで，計算したら答えが得られるような継続を作り出し
;; て，再帰している．最初に与える継続は #'(lambda () +empty+) だから，
;; これに (suc (funcall 継続)) というものをどんどん作っているわけだ．最
;; 後に n がゼロのときにそれまでの継続が一気に計算される．

(make-ord #'(lambda () +empty+) 5)
;=>  {{},{{}},{{},{{}}},{{},{{}},{{},{{}}}},{{},{{}},{{},{{}}},{{},{{}},{{},{{}}}}}}
(equals (suc (suc (suc (suc (suc +empty+)))))
        (make-ord #'(lambda () +empty+) 5))
;=>  T

;; ところで，もしオプショナルの n を与えないと，延々と継続が作られて終
;; わることがない．つまり無限に継続をつくりつづけるわけ．もちろんメモリ
;; には限界があるから，たとえコンパイルしてあっても，最後にどこかでスタッ
;; クオーバフローになる．だから普通は n を与えないということはない．実
;; 際には行うことのない単なるお話としているわけだ．でも整合的でしょ．そ
;; して，ちょうど +empty+ が空集合を表すように，+omega+ なるものを次の
;; ように定義する．

(import 'sb-int:delay)
(defparameter +omega+ (delay (make-ord #'(lambda () +empty+))))

;; ここで delay を与えているのは，そうでもしないと無限の継続を作り出し
;; てしまうから，とりあえず評価を抑制しようとして与えているだけなのだ．
;; 決して force しないでね．でもこれで，今まで +empty+ から出発して，集
;; 合演算を用いて順序数を扱えるようにしてきたのと同様に，今度は
;; +omega+ から出発して，同様な計算の枠組みを作ればよい．すでに超限順序
;; 数についての色々な性質は分かっているから，それは問題なく実行できる．
;; そしてもしそうすれば，超限順序数のことがより一層分かるようになるだろ
;; う．

;; ここまで延々と話を引っ張ってきたのは，カントールのパラドックスを紹介
;; したいがためだった．カントールは冪集合の濃度（有限の場合はカージナリ
;; ティ）はもとの濃度よりも大きいということを証明した．それはいいのだが，
;; すべての順序数の集合を考えた時（それをAとする），それも順序数だから
;; （それをa と表記する，a = A)すべての順序数の集合Aに含まれるはずだ
;; （すなわち，(in a A)）．そうすると (subset a A) だし，濃度も順序も
;; a < A = a となって矛盾する．同様なパラドックスはブラリフォルティも発
;; 見している．さあ，皆さんは何がいけないのかわかりますか．

;; これまで，外延的な集合しか考えてこなかった．それは集合の記述はとにか
;; くその要素の集まりであるという記述だ．そして，可算個無限の話，超限順
;; 序数の話（竹内外史さんの言葉ではωを含んでいても，まだまだたかだか加
;; 算個無限らしいです．アレフ0を超えない．）を展開し，カントールのパラ
;; ドックスを紹介した．一方，内包的な集合記述もある．すなわち，ある性質
;; を持つものを集合とするという記述で，こちらの方がより一般的に用いられ
;; るが，ここでも今度はラッセルのパラドックスが現れる．次は，そういう話．

;; まだ途中ですが，ここまでのところのプログラムをここに置きました．よろ
;; しかったらダウンロードしてみてください．

;; delay length=1
;; http://blog.livedoor.jp/s-koide/archives/1897896.html
;; では、set-elementsで定義されているので、こちらも合せた方がブログを辿っている人には優しいかなと思いました

;; こんにちは、毎回の更新を楽しみにしています。
;; 瑣末なことですが、ブログを一緒に辿っている人もいるかと思い今回躓きそうなところを挙げさせて頂きます。
;; (1) delay length=1は恐らくschパッケージから持ってくるのだと思いますが、scheme.zipでの定義を眺めた限りでは、exportされている訳ではないようですので、(:import-from :sch :delay :length=1)としないとzfパッケージ内で有効にならないのではないかと思えました。
;; (2) 以前のページ( http://blog.livedoor.jp/s-koide/archives/1897896.html )では、member-ofが、set-elementsとなっているので記述をmember-ofに合せた方が優しいかなと思いました。
;; 以上です。
